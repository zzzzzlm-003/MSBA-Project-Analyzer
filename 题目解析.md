# Efficient Tasks 题目解析

## 一、问题描述

### 核心任务
给定 n 个软件模块，每个模块有难度值 `difficulty[i]`，需要：
1. **分配阶段**：将模块分配到 3 个服务器（每个服务器至少 1 个模块）
2. **选择阶段**：从每个服务器中选择 1 个模块（d₁, d₂, d₃）
3. **计算难度**：使用公式 `|d₁ - d₂| + |d₂ - d₃|` 计算总体部署难度

### 约束条件
- 每个服务器必须至少处理一个模块
- 每个模块必须精确地部署到一个服务器
- 对于每种分配方式，我们选择 d₁, d₂, d₃ 来**最小化** `|d₁ - d₂| + |d₂ - d₃|`
- 在所有可能的分配方式中，找到**最小化部署难度的最大可能值**

## 二、关键理解

### 1. 两步优化问题
- **外层优化**：尝试所有可能的三分组方式
- **内层优化**：对于每种分组，选择最优的 d₁, d₂, d₃ 来最小化难度

### 2. 目标函数
```
难度 = |d₁ - d₂| + |d₂ - d₃|
```
这个公式表示：
- d₁ 和 d₂ 之间的差距
- d₂ 和 d₃ 之间的差距
- 两者之和

### 3. 最终目标
在所有可能的分组中，找到**最小化难度的最大值**（maximize the minimum）

## 三、示例详解

### 示例 1：difficulty = [1, 10, 5, 9]

**一种分组方式：**
- 组 1: `[1]` → 只能选 d₁ = 1
- 组 2: `[5]` → 只能选 d₂ = 5  
- 组 3: `[10, 9]` → 可以选择 d₃ = 10 或 d₃ = 9

**选择最优 d₃：**
- 如果选 d₃ = 10：`|1 - 5| + |5 - 10| = 4 + 5 = 9`
- 如果选 d₃ = 9：`|1 - 5| + |5 - 9| = 4 + 4 = 8` ✓（更小）

所以这种分组的最小难度是 **8**

### Sample Case 0：difficulty = [1, 2, 5, 3, 5]

**分组方式：**
- Group 1: `[1]` → d₁ = 1（唯一选择）
- Group 2: `[5, 5]` → d₂ = 5（唯一选择，因为两个都是5）
- Group 3: `[2, 3]` → 可以选择 d₃ = 2 或 d₃ = 3

**选择最优 d₃：**
- 如果选 d₃ = 2：`|1 - 5| + |5 - 2| = 4 + 3 = 7`
- 如果选 d₃ = 3：`|1 - 5| + |5 - 3| = 4 + 2 = 6` ✓（更小）

所以这种分组的最小难度是 **6**

**题目要求**：在所有可能的分组中，找到最小难度的最大值。如果这种分组方式在所有分组中能产生的最小难度最大，那么答案就是 6。

### Sample Case 1：difficulty = [5, 6, 4, 1, 5, 5]
输出：**8**

## 四、解题思路

### 方法 1：暴力枚举（小规模数据）
1. 枚举所有可能的三分组方式
2. 对于每种分组，找到最优的 d₁, d₂, d₃ 选择
3. 记录每种分组的最小难度
4. 返回所有最小难度中的最大值

### 方法 2：优化策略
- 对于给定的三个组，如何选择最优的 d₁, d₂, d₃？
  - 策略 A：固定 d₁ 和 d₃，选择最优的 d₂
  - 策略 B：固定 d₂，选择最优的 d₁ 和 d₃
  - 策略 C：遍历所有可能的组合

### 关键观察
- 由于数组可以排序，最优分组通常涉及排序后的连续子数组
- 但根据示例，分组可能不要求连续（如 Sample Case 0 中 Group 3 是 [2, 3] 而不是连续的）

## 五、算法复杂度

- 分组方式数量：C(n, 3) 级别（如果允许任意分组）
- 如果只考虑排序后的连续分组：O(n²) 种分组方式
- 对于每种分组，选择最优 d₁, d₂, d₃：O(组大小) 或 O(1)（如果使用优化策略）

## 六、待确认的问题

1. **分组是否必须连续？**
   - 从 Sample Case 0 看，Group 3: [2, 3] 在排序后的数组 [1, 2, 3, 5, 5] 中是连续的
   - 但原始数组是 [1, 2, 5, 3, 5]，所以分组可能不要求按原始顺序连续

2. **是否允许任意分组？**
   - 如果允许任意分组，复杂度会很高
   - 如果只允许排序后的连续分组，复杂度较低

3. **选择策略的精确性**
   - 需要确保找到真正的最小值，而不仅仅是近似值
